[일반 프로그래밍과 머신러닝의 차이]

1. 일반 프로그래밍
[데이터] -> [일반 프로그래밍, int main()] - [답]
                            {for ()
                               return;
                               }
--> 데이터를 입력하여 답 도출

2. 머신 러닝
[데이터, 답] -> [머신 러닝, 0:000111   ] -> 규칙
                           1 : 111000
                           0 : 000111
--> 데이터 안에서 규칙을 발견하여, 그 규칙을 새 데이터에 적용하여 답 도출


[퍼셉트론]
-> 인간의 뇌세포를 구성해서 논리회로를 구축하는 것


[머신 러닝, 딥러닝(학습)]
-> 데이터가 입력되고 패턴이 분석되는 과정


[가장 훌륭한 예측선 찾기]
-> 선형 회귀, 로지스틱 회귀 사용

[단순 선형 회귀]
-> 입력 변수가 하나인 것

[다중 입력 변수]
-> 입력 변수가 여러개인 것


[평균 제곱 오차] = 손실함수
-> 선의 오차를 판별할 때 오차를 구하는 방법

MSE = (1/n) * Sum((y-y_pred)**)
(y=실제값, y_pred=예측값)


[선형회귀]
-> 임의의 직선 y = ax + b 를 그어 이에 대한 평균 제곱 오차를 구하고 , 이 값을 가장 작게 만들어 주는 a값과 b값을 찾아가는 작업

[회귀 분석 중 찾고자 하는 것]
-> 예측선 
(회귀 분석 중)
y=ax + b => H(x) = wx + b
기울기 a = 가중치 w(weight)
절편 b = 편향 b(bias)


[경사 하강법](SGD) = 옵티마이저
-> 오차의 변화에 따라 이차 함수 그래프를 만들고 적절한 학습률을 설정해 미분값이 0인 지점을 구하는 것

[로지스틱 회귀]
-> 참과 거짓 중 하나를 내놓는 과정




[코딩 명령어]
1. from (라이브러리 명) import (함수 명) -> 환경 준비 단계에서 사용, 라이브러리를 불러옴
   = import (라이브러리 명) as (새 이름)

2. data_set = np.loadtxt("./data/데이터명) -> 데이터 준비 단계에서 사용, 사용할 데이터를 코랩으로 불러옴
3. X =- Data_set[:,0:16] -> 데이터 셋 지정, 1~16 = 속성(atteibute), 정답에 해당하는 17번 = 클래스(class)
4. 1에서 불러온 함수(함수 명)을 model로 선언, model.add()를 이용해 함수를 한 줄 추가하여 내부의 층 만들기
   *model.add안에는 Dense() 함수 포함
5. model.complie() 함수는 앞서만든 model의 설정을 그대로 실행, (안에는 loss, optimazer(선형회귀), metrics 등 키워드 포함]
6. model.fit() 함수, 한 번 오갈 때 몇개의 데이터를 사용할 것인지 정하는 함수

7. 라이브러리.array = ([]) 배열, 배열속 원소의 평균을 구하는 함수 = mean() 함수
8. divisor -> x의 각 원소와 x의 평균값의 차를 제곱하라
9. dividend -> 새로운 함수를 정의해 저장
10. 기울기 a = dividend = divisor
11. y절편 구하기, b = my - (mx*a)     y절편 = y걊 평균 - (원소 x값 X 기울기)



